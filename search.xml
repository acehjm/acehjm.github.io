<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Redis数据类型]]></title>
    <url>%2F2019%2F01%2F20%2FRedis%E4%B9%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[Redis常用数据类型： strings：二进制安全的字符串； lists：根据插入顺序排序的字符串元素的集合，基本上是链表； sets：唯一的，未排序的字符串元素的集合； zsets：有序集合，没个字符串元素都与一个浮点数关联，称为分数，元素总是按分数排序； hashs：散列或字典，是由与值相关联的字段组成的映射，字段和值都是字符串； Redis键Redis键是二进制安全的，这意味着我们可以使用任何二进制序列作为键，从字符串（包括空字符串）到jpeg等文件的内容都是有效键。 关于键的一些使用原则： 避免使用很长的键：键的长度不超过1024位，过长的键对内存不友好，即使当前任务是匹配最大值，在数据库中查找键也需要几次昂贵的比较，对于一些过长的键，可以使用hash之后的结果作为键。 避免使用过短的键：比如“u1000flw”和“user:1000:flowers”，虽然较短的键可以减小内存空间的使用，但是从可读性方面会差很多。 尽量使用格式化键：像“object-type:id”这种格式，如“user:1000”，点或短划线通常用于多词字段，如“common​:12345:reply.to​”或“common:12345:reply-to”。 允许的键的最大大小为512M。 字符串（strings）Redis中的字符串类型键值都是字符串，即将一个字符串映射到另外一个字符串。值的字符串类型可以是各种类型的字符串，如二进制数据、空字符串、jpeg图像等。字符串类型值的大小不能超过512M。 图示 字符串常用命令 SET：设置字符串值（如果该键对应的值已存在，直接覆盖）； GET：检索字符串值； INCR：解析字符串值作为整数，以一增加它，最后将获得的值作为新的值。 INCR具有原子性，即使是对同一个键的多个客户的，永远也不会进入竞争状态。例如，在同一时间，不会发生客户端1和客户端2同时读取到“10”，两者都增加到11，并设置新值为11。执行增量操作时，根据原子性最终值为12。 其它命令如DECR为自减1操作，GETSET命令将键设置为新值并返回旧值，MSET和MGET分别用于批量设置和批量获取值。 改变和查询键空间有些命令没有在特定类型上定义，这些命令为通用命令，与键交互时非常有用，因此可以与任何类型的键一起使用。例如EXISTS命令返回1或0表示数据库中是否存在给定的键，而DEL命令删除键和值（不管值类型），DEL本身返回0或1，具体取决于键是否存在，TYPE命令则返回指定键中值的类型。 Redis过期时间EXPIRE过期时间也是一个与键类型无关的功能。可以为所有的键设置有效期，当有效期过去时，键会自动销毁，和用户主动调用DEL命令一样。 关于EXPIRE的一些说明，可以使用秒或毫秒进行设置，但是到期时间解析度始终为1毫秒，有关过期时间会被复制并保存在磁盘上，当Redis服务器保持停止时，这个时间实际上会消失（Redis会保存键过期的日期）。 列表（lists）]]></content>
      <tags>
        <tag>技术</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 性能调优（一）]]></title>
    <url>%2F2018%2F12%2F15%2FJava-%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[造成系统瓶颈计算资源的因素有很多，包括CPU资源的调度、内存的读写、磁盘IO、网络IO、数据库、竞争锁、异常等。而系统性能的衡量指标有响应时间、启动时间、执行时间、执行速度、磁盘吞吐量、网络吞吐量、负载承受能力等。那么，从软件的角度看，性能优化的目标有，编写更高效的代码、使用更高效的算法、减少竞争锁、分布式集群、微服务等。而性能的优化策略有，用空间换时间、用时间换空间、优化代码、并行处理等。系统的优化来自三个方面，基础技术、层次方面、架构方面。 Java API调用优化建议面向对象及基础类型 采用clone()方式创建对象：clone()是Object类中的方法，使用时需实现Cloneable接口。当我们使用new关键字创建实例的时候，构造函数中所有构造参数都会被自动调用，而clone()不会调用任何构造函数，避免参数的初始化，在保留原有信息的基础上，创建速度更快。 拷贝对象返回的是一个新对象，而不是原来对象的引用地址。 拷贝对象与new关键字操作符返回的新对象的区别是，这个拷贝已经包含了一些原来对象的信息，而不是对象的初始化信息。 避免对boolean的判断：boolean被定义为存储8位（1字节）数值的形式，但只能是true或者false。在使用boolean时，避免使用等于判断，准确的说是不要使用3=3 == true这种形式的判断。 多用条件操作符：大部分时候，我们在代码中比较多用if(...) return; else return;这种形式的判断，但是条件使用太多，对代码的可读性带来影响，因此一些条件语句可以替换为诸如return isdone?0:1这种形式。 静态（static）方法代替实例方法：为了方便的实现多态的支持，实例方法需要维护一张类似虚拟函数导向表的结构，因此，在调用实例方法时会消耗更多的系统资源，使用类加载时就会初始化的静态方法会更快一些。静态方法和实例方法的两点区别： 在外部调用静态方法时，可以使用“类名.方法名”或“对象名.方法名”的方式，而实例方法只能通过后者调用，即静态方法无需创建对象。 静态方法在访问本类成员时，只允许访问静态成员，而不允许访问实例成员变量和实例方法，，实例方法则无此限制。 有条件的使用final关键字：final关键字可以修饰类、变量、方法，在使用匿名内部类的时候，经常会用到final关键字，如String类。使用final可以锁定方法，以防止任何继承类修改它的含义，在早期的Java版本中，会将final方法转为内嵌调用，JDK6之后无需此优化。 避免不需要的instanceof操作：instanceof关键字是Java的一个二元操作符，和“==”“&gt;”类似，使用instanceof比较左边的对象是否是右边类的实例，会返回true或false。合理利用多态特性，可以避免instanceof的使用。 避免子类中存在父类转换：Java中，所有子类隐含的“等于”父类，因此在子类中无需再转换。 多使用局部变量：调用方法时传递的参数在调用中创建的临时变量都被保存在栈（Stack）里面，因此读写速度更快。像静态变量、实例变量，它们在堆（Heap）中被创建，保留在堆中，读写速度较慢。 实例对象属于对象的属性，使用时必须创建对象，其实例对象才会被分配空间，才能使用它。静态变量属于类，只要程序加载了类的字节码，不用创建任何实例对象，就会被分配空间。 使用效率最高的位运算：位运算表达式由操作数和位运算符组成，实现对整数类型的二进制数位运算。位运算符可以分为逻辑运算符（包括～、&amp;、|、^）及移位运算符（包括&gt;&gt;、&gt;&gt;&gt;、&lt;&lt;）。 &gt;&gt;&gt;和 &gt;&gt;的区别是，在执行运算时，&gt;&gt;&gt;运算符的操作数高位补0，而&gt;&gt;运算符的操作数高位移入原来的高位的值。 右移以为相当于除以2，左移一位相当于乘以2（位运算速度高于乘除运算）。 若进行位逻辑运算的两个操作数的长度不同，则返回值以数据长度较长的数据类型为准。 按位异或可以不使用临时变量完成两个值的交换，也可以使某个整型数的特定位的翻转。 按位与运算可以用来屏蔽特定的位，也可以用来取某个整型数中特定的位。 按位或运算可以用来对某个整型数的特定位置的值置1. 用一维数组代替二维数组：数组的优点是随机访问性能好。二维数组的访问速度要优于一位数组，但是，二维数组占用空间是一维数组的10倍左右。在性能敏感的系统中使用二维数组，如果内存不足，尽量将二维数组替换为一维数组再处理。（二维数组是典型的空间换时间做法） 布尔运算代替位运算：使用位运算代替布尔运算会使系统多很多无效计算，比如a&amp;&amp;b&amp;&amp;c，当有一个为false时，会跳过后面的计算直接返回结果，但是位运算需要将所有的表达式都计算完才返回结果。 提取表达式优化：将方法中或代码块中的相同的表达式提取出来，避免重复计算，如a*b*c+d，没次计算都会消耗资源，提取出来只计算一次即可。 不要总是使用取反操作符（!）：!取反操作符表示异或操作，使用起来方便，但是它会降低程序的可读性。 不要重复初始化变量：默认情况下，调用类的构造函数时，Java会把变量初始化为一个确定的值，例如将所有对象设置为null，因此，一般情况下，通过构造函数初始化对象。 在switch语句中使用字符串：在switch或case表达式中，值不能为null，否则会抛空指针异常。在编译时，将字符串hashcode()之后，转为与整数类型兼容的格式。 数字字面常量的改进：可以将十进制、十六进制转为二进制表示，比如数字9用二进制表示为0b001001。当一个数字太长的时候，使用_分隔符分开，比如5000000可以改成5_000_000。 优化变长参数方法的调用：一般情况下，方法的参数不宜过多，且最后一个参数为变长参数时，避免和泛型类型一起使用。 基本数据类型-空变量：通过显式的赋空变量，Eden（新生代的一个区域）就能在新对象创建之前获得自由空间，这样垃圾收集就会更快。 集合处理优化方案 集合中删除元素：List list = new ArrayList&lt;~&gt;()中，不能直接使用remove()方法删除元素，会发生错误，应该使用Iterator中的删除方法。 集合内部避免返回null：在需要返回数组或集合的方法中，如果需要返回空数据，返回大小为0的数组或集合，避免返回null（在调用方不判空情况下，返回null可能会发生NPE）。 使用迭代、流、并行流：JDK8及以上提供，可读性更好，不易出错，容易并行化。比如：forEach()是线程安全的。可以对其进行并行处理，stream替换为parallelStream（对性能造成严重影响）就可以执行过滤和统计操作。 字符串优化方案 善用subString()方法：String.subString()可以截取字符串，该方法适用于字符串长度较短时，当字符串长度很大时，会占用很大的内存，造成内存溢出，可以使用new String(smallStr.toCharArray())替代。因此，当需要截取的字符串长度总和远小于原始字符串文本长度时，使用new String(smallStr.toCharArray())，在大文本字符串处理中有很大优势。当需要截取的字符串长度总和大于原始文本字符串长度时，使用String.subString()可以达到共享内存的目的。 查找单个字符，用chart()代替startsWith()和endsWith()：从性能角度来说，前者会快一些。 字符串相加时，仅一个字符，使用’’替代””：使用字符替代。 字符串切割：使用split()方式切分字符串时性能较差。对比发现，使用StringTokenizer解析字符串更快。StringTokenizer类允许一个应用程序进入一个令牌（Token），StringTokenizer类的对象在内部已经标示化的字符串中维持了当前位置。一些操作使得现有位置上的字符串提前得到处理，一个令牌的值是由获得其曾经创建StringTokenizer类对象的字符串返回的。 字符串连接：字符串连接的方式一般有string对象连接、concat方法、StringBuilder类。而StringBuffer对所有方法都做了同步处理，效率较低，但是在多线程环境下，StringBuilder不是线程安全，无法使用。StringBuilder和StringBuffer两者底层实现都是char[]。对比，性能依次为StringBuilder &gt; concat &gt; string+&#39;a&#39;。 正则表达式：正则表达式不是万能的，根据实际情况使用。 其它优化 循环优化：应尽可能减少循环。 使用arrayCopy()：数组复制是一个使用频率很高的功能，System.arrayCopy()函数是native函数，通常native函数性能优于普通函数，ArrayList中大量使用该函数。arrayCopy的本质是让处理器利用一条指令处理一个数组中的多个记录，有点像汇编语言里面的串操作指令，只需要指定头指针，然后开始循环即可，即执行一次指令，指针就后移一个位置，操作多少次就循环多少次。 使用Buffer进行IO操作：多使用缓冲区。]]></content>
      <tags>
        <tag>java</tag>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis知识点梳理]]></title>
    <url>%2F2018%2F12%2F12%2FMybatis%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86%2F</url>
    <content type="text"><![CDATA[Mybatis架构图： 基础支持模块 解析器模块 XML解析：DOM（Document Object Model）、SAX（Simple API for XML）、StAX（Streaming API for XML） DOM：基于树形结构的XML解析方式，它会将整个XML文档读入内存并构建一个DOM树，基于该树对各个节点（Node）进行操作。 SAX：基于事件模型的XML解析方式，它将XML文档的一部分加载到内存中，即可开始解析，在处理过程中并不会在内存中记录XML中的数据，所以占用资源比较少。当程序处理过程中满足条件时，也可以立即停止解析过程。SAX没有写XML文档的能力，是一种推模式。 StAX：JDK提供，可以很好支持DOM和SAX解析方式，与SAX类似，也是把XML文档作为一个事件流进行处理，不同之处在于StAX使用的是拉模式（即应用程序通过调用解析器推进解析的进程）。 XPath：一种为查询XML文档设计的语言，它使用路径表达式选取XML文档中的节点或节点集合，常结合DOM解析方式一起使用。 MyBatis 中使用了DOM加XPath的解析方式。 反射工具箱 Reflector：是Mybatis中反射模块的基础，每一个Reflector对象都代表对应的一个类，在Reflector中缓存了反射操作需要使用的类的元信息。 ReflectorFactory：该接口主要实现了对Reflector对象的创建和缓存，isClassCacheEnbale()是检测该ReflectoryFactory对象是否会缓存Reflector对象，setClassCacheEnabled(boolean classCacheEnabled)设值是否缓存Reflector对象，findForClass(Class&lt;?&gt; type)创建指定Class对应的Reflector对象。使用ConcurrentMap集合实现对Reflector对象的缓存。 TypeParameterResolver：静态解析类，提供一系列方法解析指定类中的字段、方法返回值或方法参数的类型。resolveFieldType()解析字段类型，resolveReturnType()解析返回值类型，resolveParamType()解析方法参数列表中各个参数类型。 ObjectFactory：通过重载的多个create()方法创建指定类型的对象，是一个反射工厂，其create()方法通过调用instantiateClass()方法实现。 Property工具集：PropertyTokenizer、PropertyNamer、PropertyCopier，orders[0].name这种由.和[]组成的表达式由PropertyTokenizer解析，方法名到属性名的转换以及多种检测操作由PropertyNamer解析，相同类型的两个对象之间的属性值拷贝由PropertyCopier解析，其核心方法是copyBeanProperties()。 MetaClass：通过Reflector和PropertyTokenizer组合使用，实现对复杂的属性表达式的解析，并实现了获取指定属性描述信息的功能。MetaClass中比较重要的方法是findProperty()方法，它是通过调用MetaClass.buildProperty()方法实现的，而build Property()方法会通过PropertyTokenizer解析复杂的属性表达式。 ObjectWrapper：是Mybatis对类级别元信息的封装和处理，该接口是对对象的包装，抽象了对象的属性信息，它定义了一系列查询和更新对象属性信息的方法。 MetaObject：是对属性表达式的解析，MetaObject的构造方法会根据传入的原始对象的类型以及ObjectFactory工厂的实现，创建相应的ObjectWrapper对象。 类型转换 TypeHandler：所有类型转换器都继承了TypeHandler接口，TypeHandler接口中有四个方法，分为两类，setParameter()方法负责将数据由JdbcType转换成JavaType，getResult()方法及其重载方法负责将数据由JavaType转换成JdbcType。 TypeHandlerRegistry：在Mybatis初始化过程中，会为所有已知的TypeHandler创建对象，并实现注册到TypeHanlderRegistry中，由TypeHandlerRegistry负责管理这些TypeHandler。 TypeAliasRegistry：通过该类完成别名的注册和管理工作，它通过TYPE_ALIASES字段（Map&lt;String, Class&lt;?&gt;&gt;类型）管理别名与JavaType之间的对应关系，通过TypeAliasRegistry.registerAlias()方法完成注册别名。 日志模块 日志模块使用适配器模式，定义了一套统一的日志接口供上层使用。 提供了trace 、debug、warn、error四个级别的日志。 通过JDK动态代理的方式，将JDBC操作通过日志框架打印出来，一般在开发阶段使用。 资源加载 类加载器：JVM中类加载器（ClassLoader）负责加载来自文件系统、网络或其他来源的类文件，JVM中类加载器默认使用双亲委派模式（双亲委派模式可以保证：一、子加载器可以使用父加载器已加载的类，而父类加载器无法使用子加载器已加载的类；二、父加载器已加载过的类无法被子加载器再次加载。），即子加载器委托父加载器加载。 ClassLoaderWrapper：是ClassLoader的包装器，其中包含了多个ClassLoader对象，通过调整多个类加载器的使用顺序，ClassLoaderWrapper可以确保返回给系统使用的是正确的类加载器。 ResolverUtil：可以根据指定条件查找指定包下的类，ResolverUtil中使用classLoader字段记录当前现场上下文绑定的ClassLoader，可以修改使用类加载。 虚拟文件系统（VFS）：VFS是一个抽象类，用来查找指定路径下的资源。 数据源模块 DataSourceFactory：有UnpooledDataSourceFactory和PooledDataSourceFactory类。 UnpooledDataSource：未池化，频繁使用会耗资源。 PooledDataSource：实现数据库连接的重用、提高响应速度、防止数据库连接过多造成数据库假死、避免数据库连接泄漏等。数据库连接池会控制连接总数的上限以及空闲连接的上限，如果连接池创建的总连接数已达上限，且已都被占用，则后续请求连接的线程会进入阻塞队列等待，知道有线程释放出可用的连接。如果连接池中空闲连接数较多，达到其上限，则后续返回的空闲连接不会放入池中，而是直接关闭，可以减少系统维护多余数据库连接的开销。 在配置时，空闲连接上限不能设置过大（浪费系统资源来维护空闲连接），也不能设置过小（出现瞬间峰值请求时，系统响应能力较弱），需根据性能测试、权衡以及一些经验配置。 事物管理模块 对数据库事务进行了抽象。 五个接口：getConnection()获取对应的数据库连接，commit()提交事物，rollback()回滚事物，close()关闭数据库连接，getTimeOut()获取事物超时时间。 绑定模块 Mapper接口类中方法和XML文件中key的映射处理操作。 MapperRegistry：是Mapper接口及其对应的代理对象工厂的注册中心。 MapperProxyFactory：主要负责创建代理对象。 MapperProxy：实现了InvocationHandler接口。 MapperMethod：封装了Mapper接口中对应的方法的信息，以及对应SQL语句的信息。 缓存模块 分为两层结构：一级缓存和二级缓存，本质上一样，都是Cache接口的实现。 Cache：定义了所有缓存的基本行为。 CacheKey：可以添加多个对象，由这些对象共同确定两个CacheKey对象是否相同，CacheKey重写了equals()方法和hashCode()方法。 核心处理模块 Mybatis初始化的主要工作是加载并解析mybatis-config.xml配置文件、映射配置文件以及相关的注解信息。 Mybatis的初始化入口是SqlSessionFactoryBuilder.build()。首先是读取配置文件，然后解析文件得到Configuration对象，创建DefaultSqlSessionFactory对象。 Configuration是Mybatis初始化过程中的核心对象，几乎全部配置信息都会保存到Configuration对象中，它是在Mybatis初始化过程中创建且是全局唯一。 XMLConfigBuilder是BaseBuilder子类之一，主要负责解析mybatis-config.xml配置文件，它的parse()方法是解析配置文件的入口。 XMLMapperBuilder负责解析映射配置文件，也是继承BaseBuilder抽象类，parse()方法是解析配置文件的入口。 XMLStatementBuilder用来解析SQL节点，Mybatis使用SqlSource接口表示映射文件或注解中定义的SQL语句，但它表示的SQL语句不能直接被数据库执行，因为其中可能含有动态SQL语句相关的节点或是占位符等需要解析的元素。 SqlNode用来解析SQL语句中定义的动态SQL节点、文本节点等。 SqlSource接口中getBoundSql(Object parameterObject)方法通过解析得到BoundSql对象，其中封装了包含&quot;?&quot;占位符的SQL语句，以及绑定的实参。 DynamicContext主要用来记录解析动态SQL语句之后产生的SQL语句片段，可以认为它是一个用于记录动态SQL语句解析结果的容器。 SqlSourceBuilder主要完成两方面的操作，一方面是解析SQL语句中的#{}占位符中定义的属性，格式类似于#{_frc-item_0,javaType=int,jdbcType=NUERIC,typeHandler=MyTypeHandler}，另一方面是将SQL语句中的#{}占位符替换成?占位符。 DynamicSqlSource负责解析动态SQL语句，也是最常用的SqlSource实现之一。 RowSqlSource是SqlSource的另一个实现，其逻辑与DynamicSqlSource类似，但是执行的时机不一样，处理的SQL语句类型也不一样。RowSqlSource在构造方法中首先会调用getSql()方法，其中通过调用SqlNode.apply()方法完成SQL语句的拼接和初步处理，之后会使用SqlSourcebuilder完成占位符的替换和ParameterMapping集合的创建，并返回StaticSqlSource对象。 ResultSetHandler负责映射select语句查询得到的结果集，同时还会处理存储过程执行后的输出参数。 KeyGenerator接口提供业务逻辑需要获取插入记录时产生的自增主键。 StatementHandler是Mybatis的核心接口之一，它的接口功能有创建Statement对象，为SQL语句绑定实参，执行select|insert|update|delete等多种类型的SQL语句，批量执行SQL语句，将结果集映射成结果对象等。 Executor是Mybatis核心接口之一，其中定义了数据库操作的基本方法。在实际应用中经常涉及的SqlSession接口的功能，都是基于Executor接口实现的。 接口模块 SqlSession中定义了常用数据库操作方法，如增删改查等。 插件 Mybatis中，插件通过拦截器的方式实现，可以自定义很多强大的功能，如主键生成、黑白名单、分页、分库、分表等。]]></content>
      <tags>
        <tag>技术</tag>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些技术类相关概念的整理]]></title>
    <url>%2F2018%2F12%2F12%2F%E6%8A%80%E6%9C%AF%E6%A6%82%E5%BF%B5%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[技术名称/概念太多，一些很少用到但是要接触的概念还是要记录下来，写在这里的目的是，进来就能看到。 多租户多租户技术（英语：multi-tenancy technology）或称多重租赁技术，是一种软件架构技术，它是在探讨与实现如何于多用户的环境下共享相同的系统或程序组件，并且仍可确保各用户间数据的隔离性。 在多租户技术中，租户（tenant）是指使用系统或计算机运算资源的客户，但在多租户技术中，租户包含在系统中可识别为指定用户的一切数据，举凡账户与统计信息（accounting data），用户在系统中建置的各式数据，以及用户本身的客制化应用程序环境等，都属于租户的范围，而租户所使用的则是基于供应商所开发或建置的应用系统或运算资源等，供应商所设计的应用系统会容纳数个以上的用户在同一个环境下使用，为了要让多个用户的环境能力同一个应用程序与运算环境上使用，则应用程序与运算环境必须要特别设计，除了可以让系统平台可以允许同时让多份相同的应用程序运行外，保护租户数据的隐私与安全也是多租户技术的关键之一。 技术上，多租户技术可以透过许多不同的方式来切割用户的应用程序环境或数据。 数据面（data approach）：供应商可以利用切割数据库（database），切割存储区（storage），切割结构描述（schema）或是表格（table）来隔离租户的数据，必要时会需要进行对称或非对称加密以保护敏感数据，但不同的隔离作法有不同的实现复杂度与风险。 程序面（application approach）：供应商可以利用应用程序挂载（hosting）环境，于进程（process）上切割不同租户的应用程序运行环境，在无法跨越进程通信的情况下，保护各租户的应用程序运行环境，但供应商的运算环境要够强。 系统面（system approach）：供应商可以利用虚拟化技术，将实体运算单元切割成不同的虚拟机，各租户可以使用其中一至数台的虚拟机来作为应用程序与数据的保存环境，但对供应商的运算能力要更要求。]]></content>
      <tags>
        <tag>技术</tag>
        <tag>概念</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring boot custom HttpMessageConverter with kotlin]]></title>
    <url>%2F2017%2F04%2F13%2Fspring-boot-custom-HttpMessageConverter-with-kotlin%2F</url>
    <content type="text"><![CDATA[Make everything as simple as possible, but not simpler. ​ — Albert Einstein 在 Spring Boot 开发过程中，有时候需要自定义数据类型，而默认的 HttpMessageConverter 不能将自定义数据类型序列化为想要的数据，因此需要自定义序列化与反序列化。Gson 或 Jackson 实现 自定义类型为 CustomType 。 Gson 实现，继承 GsonHttpMessageConverter 类，并实现 JsonSerializer 和 JsonDeserializer 接口 12345678910111213141516171819202122class CustomGsonHttpMessageConverter : GsonHttpMessageConverter() &#123; init &#123; //自定义Gson转换器 super.setGson(GsonBuilder() .serializeNulls() //null值属性也需要序列化(添加此项可将实体类中为空的数据序列化到json中，其值为null //注册到Gson的类型适配器 .registerTypeAdapter(CustomType::class.java, CustomTypeConverterAdapter()) .create()) &#125; //----------JsonSerializer-------JsonDeserializer------ //自定义CustomType序列化与反序列化 inner class CustomTypeConverterAdapter : JsonSerializer&lt;CustomType&gt;, JsonDeserializer&lt;CustomType&gt; &#123; override fun serialize(src: CustomType?, typeOfSrc: Type, context: JsonSerializationContext): JsonElement = if (src == null) JsonPrimitive("") else JsonPrimitive(src.toString()) override fun deserialize(json: JsonElement, typeOfT: Type, context: JsonDeserializationContext): CustomType = CustomType(json.asJsonPrimitive.asString) &#125;&#125; Jackson 实现，继承 MappingJackson2HttpMessageConverter 类，分别继承抽象类 JsonSerializer 和 JsonDeserializer 12345678910111213141516171819202122232425class CustomJackson2HttpMessageConverter : MappingJackson2HttpMessageConverter() &#123; init &#123; super.setObjectMapper( Jackson2ObjectMapperBuilder() //通过自定义类型注册到ObjectMapper .deserializerByType(CustomType::class.java, CustomTypeDeserialize()) .serializerByType(CustomType::class.java, CustomTypeSerialize()) .serializationInclusion(JsonInclude.Include.NON_NULL) .build() ) &#125; inner class CustomTypeDeserialize : JsonDeserializer&lt;tag_t&gt;() &#123; override fun deserialize(parser: JsonParser?, context: DeserializationContext?): CustomType = CustomType(parser?.text ?: "") &#125; inner class CustomTypeSerialize : JsonSerializer&lt;tag_t&gt;() &#123; override fun serialize(value: CustomType?, generator: JsonGenerator?, provider: SerializerProvider?) &#123; generator?.writeString(value?.toString() ?: "") &#125; &#125;&#125; 最后通过 WebConfig 配置消息转换器 1234567891011@Configurationopen class WebConfig : WebMvcConfigurerAdapter() &#123; override fun configureMessageConverters(converters: MutableList&lt;HttpMessageConverter&lt;*&gt;&gt;) &#123; //注册多个HttpMessageConverter(按顺序调用) converters.add(CustomGsonHttpMessageConverter()) converters.add(CustomJackson2HttpMessageConverter()) super.configureMessageConverters(converters) &#125;&#125; 以上通过 Java Configure 的方式配置，也可通过在 application.yml 文件中配置相关数据。]]></content>
      <tags>
        <tag>技术</tag>
        <tag>java</tag>
        <tag>kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin & Spring boot 使用@Valid校验无效解决方法]]></title>
    <url>%2F2017%2F04%2F12%2FKotlin-Spring-boot-%E4%BD%BF%E7%94%A8-Valid%E6%A0%A1%E9%AA%8C%E6%97%A0%E6%95%88%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[kotlin data （对应Java实体类 123456789101112131415161718@Entity@Table(name = "user")data class User( @NotNull(message = "用户名不能为空") @Column(name = "user_name", nullable = false) var userName: String = "", @NotNull(message = "用户ID不能为空") @Column(name = "user_id", unique = true) var userId: String = "", @Email(message = "无效的邮箱") var email: String = "", @Column(nullable = false) var password: String = "") : Serializable 再来看controller 123456789101112131415161718192021222324@RestController@RequestMapping("/user")class UserController &#123; @Autowired lateinit var userRepository: UserRepository @PutMapping(value = "/put", consumes = arrayOf(MediaType.APPLICATION_JSON_UTF8_VALUE)) fun put(@Valid @RequestBody user: SysUser): ResponseEntity&lt;SysUser&gt;? &#123; if (result.hasErrors()) &#123; val fieldErrors = result.fieldErrors for (fieldError in fieldErrors) &#123; println("$&#123;fieldError.defaultMessage&#125;") &#125; return fieldErrors &#125; println(user) return ResponseEntity .ok() .cacheControl(CacheControl.maxAge(30, TimeUnit.DAYS)) .eTag("AC") .body(user) &#125;&#125; 调用put方法，@Valid校验无效 原因分析： 在 java 中，将 validation 注解到实体类属性或者 get/set 方法上，但是在 kotlin 中，属性直接写在构造函数中，validation 注解并没有作用到属性上。 解决方法： 使用 @field: 标识符，field标识符只允许在属性的访问器函数内使用。它能够 validation 校验注解作用与属性。 将 kotlin data class 稍作修改： 1234567891011121314151617181920@Entity@Table(name = "user")data class User( @field:NotNull(message = "用户名不能为空") @Column(name = "user_name", nullable = false) var userName: String = "", @field:NotNull(message = "用户ID不能为空") @Column(name = "user_id", unique = true) var userId: String = "", @field:NotBlank(message = "邮箱不能为空") @field:Email(message = "无效的邮箱") var email: String = "", @field:NotBlank(message = "密码不能为空") @Column(nullable = false) var password: String = "") : Serializable 之后，@Valid校验即可正常工作 再次执行 1curl -v http://localhost:8080/user/put11 @Valid正常工作 123456789101112131415161718192021222324252627282930313233&#123; "timestamp": "2017-03-04 13:54:19", "status": 400, "error": "Bad Request", "exception": "org.springframework.web.bind.MethodArgumentNotValidException", "errors": [ &#123; "field": "userId", "rejectedValue": null, "bindingFailure": false, "objectName": "sysUser", "codes": [ "NotNull.sysUser.userId", "NotNull.userId", "NotNull.java.lang.String", "NotNull" ], "arguments": [ &#123; "codes": [ "sysUser.userId", "userId" ], "arguments": null, "defaultMessage": "userId" &#125; ], "defaultMessage": "用户ID不能为空" &#125; ], "message": "Validation failed for object='sysUser'. Error count: 1", "path": "/user/put"&#125;]]></content>
      <tags>
        <tag>kotlin</tag>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hibernate自定义类型]]></title>
    <url>%2F2017%2F01%2F03%2FHibernate%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[Hibernate对一些基本类型的映射提供了很好的支持，但有时候我们需要映射自定义或更复杂的数据类型，比如一个List集合，可以通过基本类型映射实现，需要在数据库中新建一张表，这种方式增加了数据库开销；也可以将List集合中的数据拼接成字符串再存储，这种方式导致程序可读性不友好，同时增加代码的复杂度；Hibernate提供了DiscriminatorType和UserType接口，方便用户自定义需要映射的数据类型。这里以UserType为例实现。 假设用户需要自定义一个类型，名称为ctype，它是16位字符的char数组，需要映射到数据库VARCHAR类型。 首先自定义java类型ctype： 123456789101112131415161718192021222324252627282930313233343536373839404142public class ctype implements Serializable &#123; // mtype 的长度 private static int TYPE_LENGTH = 16; // mtype 实际上就是 char 数组 private char[] mtype = new char[TYPE_LENGTH]; // 默认构造函数 public ctype() &#123; this.mtype = new char[0]; &#125; // 通过构造函数转换为ctype类型 public ctype(Object object) &#123; String str = String.valueOf(object); if (StrUtil.isBlank(str)) this.mtype = new char[0]; this.mtype = str.toCharArray(); &#125; public boolean isEmpty() &#123; return String.valueOf(this.mtype).replace(" ", "").length() &lt; TYPE_LENGTH; &#125; public String toString() &#123; return String.valueOf(this.mtype); &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; ctype ctype = (ctype) o; return Arrays.equals(mtype, ctype.mtype); &#125; @Override public int hashCode() &#123; return Arrays.hashCode(mtype); &#125;&#125; 接下来实现HibernateUserType接口： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123/** * Hibernate自定义类型 */public class customType implements UserType &#123; private static int[] TYPES = new int[]&#123;Types.VARCHAR&#125;; /** * 修改类型对应的SQL类型（这里用VARCHAR */ @Override public int[] sqlTypes() &#123; return TYPES; &#125; /** * 修改customType对应的java类型（此处java类型为ctype */ @Override public Class returnedClass() &#123; return ctype.class; &#125; /** * 自定义数据类型比对方法 * 用作脏数据检查，o,o1为两个副本 */ @Override public boolean equals(Object o, Object o1) throws HibernateException &#123; return Objects.equals(o, o1); &#125; /** * 返回给定类型的hashCode */ @Override public int hashCode(Object o) throws HibernateException &#123; return Objects.hashCode(o); &#125; /** * 读取数据转换为自定义类型返回 * strings包含了自定义类型的映射字段名称 */ @Override public Object nullSafeGet(ResultSet resultSet, String[] strings, SessionImplementor sessionImplementor, Object o) throws HibernateException, SQLException &#123; String s = (String) resultSet.getObject(strings[0]); if (resultSet.wasNull()) return null; if (null != s) &#123; if (s.replaceAll(" ", "").isEmpty()) return null; return new ctype(s); &#125; return null; &#125; /** * 数据保存时被调用 */ @Override public void nullSafeSet(PreparedStatement preparedStatement, Object o, int i, SessionImplementor sessionImplementor) throws HibernateException, SQLException &#123; if (null == o) &#123; preparedStatement.setNull(i, Types.VARCHAR); //保存空值 &#125; else &#123; String stringValue = String.valueOf(o); preparedStatement.setString(i, stringValue); &#125; &#125; /** * 自定义类型的完全复制方法,构造返回对象 * 1. 当nullSafeGet方法调用之后，我们获得了自定义数据对象， * 在向用户返回自定义数据之前,deepCopy方法被调用， * 它将根据自定义数据对象构造一个完全拷贝，把拷贝返还给客户使用。 * 2. 此时我们就得到了自定义数据对象的两个版本 * 原始版本由hibernate维护，用作脏数据检查依据; * 复制版本由用户使用，hibernate将在脏数据检查过程中比较这两个版本的数据; */ @Override public Object deepCopy(Object o) throws HibernateException &#123; if (o == null) return null; ctype c = (ctype) o; ctype nc = new ctype(); nc = c; return nc; &#125; /** * 表示本类型实例是否可变 */ @Override public boolean isMutable() &#123; return true; &#125; /** * method called when Hibernate puts the data in a second level cache. The * data is stored in a serializable form （官方文档 */ @Override public Serializable disassemble(Object o) throws HibernateException &#123; return (ctype) deepCopy(o); &#125; /** * Returns the object from the 2 level cache （官方文档 */ @Override public Object assemble(Serializable serializable, Object o) throws HibernateException&#123; return deepCopy(serializable); &#125; @Override public Object replace(Object o, Object o1, Object o2) throws HibernateException &#123; return deepCopy(o); &#125;&#125; 通过注解方式使用： 123456789101112131415/** * Entity -&gt; Item */@Entity@Table(name = "d_item")@TypeDef(name = "myType", typeClass = customType.class)public class Item implements Serializable &#123; @Id @Type(type = "myType") private ctype uid; ... ... &#125; 完成。]]></content>
      <tags>
        <tag>技术</tag>
        <tag>java</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读看见]]></title>
    <url>%2F2016%2F01%2F29%2F%E8%AF%BB%E7%9C%8B%E8%A7%81%2F</url>
    <content type="text"><![CDATA[“痛苦是财富，这话是扯淡。姑娘，痛苦就是痛苦，”他说，“对痛苦的思考才是财富。” 对遭受的侮辱，不需要愤怒，也不需要还击，只需要蔑视。 那时看了《苍穹之下》，很触动，内心共鸣。短短两个多小时的视频，却道出了很多环境问题。而她更是以迅雷不及掩耳之势被封杀。当时想，一个眼前的问题，人人皆知，却没人说，她说了，很多人认同，也有很多人对她各种质疑。有人说她编造数据，夸大危害，哗众取宠，制造社会紧张。而我们关注的重点难道不是雾霾？难道不是恶劣的环境问题吗？很多人把矛头指向她，很多人给她护盾，这样是改变不了环境的。 从《夜色温柔》开始，先后在《时空连线》、《新闻调查》、《看见》等栏目担任主持人与记者，对她的了解，更多的不是从电视上的主持人，是现场记者。她做了很多专题，每一期都反映了当时社会的一个普遍现象。家暴、腐败、温情、非典、奥运会、征地等等，每一次的镜头都让人触动。他们几乎都是村子里最贫穷的人，几乎都酗酒，喝的时候咒骂赚了钱的人，回家打老婆孩子。有人说：“这些人，只是农村的失败者，城市里没有。” 在做这期节目的时候，谁又会想的到会有人这么说呢，是社会给他们生活绝望，他们没有看到希望，只是看到比他们好的，自己又没有能力改变什么，于是饮酒和暴力成了他们的力量，但这给家庭带来难以想象的灾难。全世界都存在难以根除的家庭暴力，没有任何婚姻制度可以承诺给人幸福，但应该有制度使人可以避免极端的不幸。是的，家暴难以根除，不仅仅是穷人，有地位的人也是，李阳拖着肥大的身体，不也对妻子施以暴力吗。拿什么去约束，法律吗？法律在哪里呢？法制的不健全也是造成施暴者和受暴者的悲剧。当事人自己更应该负起责任吧。在采访老家工厂污染时也能想象的到吧，那样的环境下还有人苦苦挣扎着生存。我有时也会常常想，为什么不搬家呢?为什么不举报不反映呢？难道就那样眼睁睁看着有人得了污染病一个个死去吗？怎么没有人站出来呢？也许就是没那么简单吧，这里不仅仅是污染者与被污染者的事，还有各方利益，政府、工厂、村民，大家都有自己的利益，何乐而不为呢？难道健康和生命就那么容易被藐视吗？ 探寻就是要不断相信、不断怀疑、不断幻灭、不断摧毁、不断重建，为的只是避免成为偏见的附庸。或者说，煽动各种偏见的互殴，从而取得平衡，这是我所理解的‘探寻，她自己也在探寻吧，在她寻求平衡的过程中，恐怕也遭受了很多无奈吧，就像那句不要太爱惜自己的羽毛 一样，人总会受伤吧，但是仅仅为了保护自己不受伤而放弃我们应得的东西是否太过懦弱了呢？你们说要争自由，自由是针对外面束缚而言的，独立是你们自己的事，给你自由而不独立，仍是奴隶。独立要不盲从，不受欺骗，不依赖门户，不依赖别人，这就是独立的精神。 可是，现在大多数人在沉默，不敢言不敢怒，不敢当家做主。这社会一副病怏怏的样子，却找不到一个可以治得好的医生。在面对那么多的问题的时候，又有多少人关心和在乎受伤的人呢？ 希望还能再听见她的声音，也希望能有更多的声音。 “无论如何，你看到的总是你自己。死在路上的甲虫，它是像你一样为了生存而奋斗的生命，像你一样喜欢太阳，像你一样懂得害怕和痛苦，现在，它却成了腐烂的肌体，就像你今后也会如此。]]></content>
      <tags>
        <tag>随笔</tag>
        <tag>看见</tag>
      </tags>
  </entry>
</search>
